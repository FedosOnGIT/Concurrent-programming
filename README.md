# 1.Stack with Elimination

Необходимо доработать реализацию `StackImpl` таким образом, чтобы она стала безопасной и эффективной при использовании из нескольких потоков одновременно.
В качестве базовой реализации используйте рассказанный на лекции алгоритм на основе односвязного списка.
Чтобы сделать алгоритм масштабируемым, необходимо использовать технику elimination.
Вы можете проверить эффективность вашего решения с помощью бенчмарка `StackBenchmark`.

1. Напишите базовую реализацию на основе односвязного списка.
2. Добавьте массив фиксированного размера (найдите оптимальное значение для вашей машины и желаемого количества параллельных потоков экспериментальным способом) для elimination-а.
3. Операция `push` пытаться записать элемент в случайную ячейку этого массива (нужно делать несколько попыток в соседних ячейках при неудачной записи) и в цикле фиксированного размера ждет изменений на этой ячейки (spin wait). Если другой поток "забрал" значение, то операция завершается. Иначе, ячейка "сбрасывается" на начальное состояние, и операция выполняется в базовой версии стека.
4. Операция `pop` должна сначала пытаться найти себе пару в массиве для elimination-а (так же делая несколько попыток). В случае неудачи идёт в бозовую версию стека.

# 2.Michael-Scott Lock-Free Queue

Необходимо доработать реализую `MSQueue` так, чтобы она стала безопасной для использования из множества потоков одновременно.
Используйте алгоритм очереди, предложенный M. Michael и L. Scott.

[Ссылка на статью](http://www.cs.rochester.edu/~scott/papers/1996_PODC_queues.pdf)

В отличие от рассказанного на лекции алгоритма, вам следует соблюдать предложенный в исходной работе инвариант
"голова не может быть правее хвоста", для поддержания которого операция `dequeue` должна помогать передвигать хвост.
Ко всему прочему, ваш алгоритм должен быть максимально простым и не содержать предлагаемые в исходной статье оптимизации.

# 3.Анализ возможных исполнений

В рамках данного задания вы проанализируете все возможные исполнения указанной ниже программы
в модели чередования операций.

```
shared int a = 0, b = 0

== Thread P: ==
while true:
  1: a = 1
  2: while b != 0: pass // do nothing
  3: pass // critical section, do nothing
  4: a = 0

== Thread Q: ==
while true:
  1: b = 1
  2: if a == 0: break // to line 4
  3: b = 0
4: stop // outside of loop
```

Чтения и записи разделяемых переменных *a* и *b* происходят атомарно.

## Задание

Нарисуйте диаграмму всех возможных различных состояний исполнения программы из двух потоков **P** и **Q** в модели
чередования операций и запишите результат в файл [solution.txt](solution.txt) использую следующую нотацию:

* Состояния системы обозначаются `[Px,Qy,a,b]` где `x` это строчка когда потока **P**, `y` строчка кода потока **Q**,
   `a` это значение в переменной a, `b` значение в переменной b. Например, начальное состояние обозначается как
   `[P1,Q1,0,0]`.
* Каждая строка в файле должна описывать возможный переход системы и иметь вид `<state1> -> <state2>`. Например,
   исполнение первой строки потока **P** в начальном состоянии записывается как `[P1,Q1,0,0] -> [P2,Q1,1,0]`.
* Можете писать комментарий после символа `#`.
* **В первой строке файла впишите вашу фамилию и имя**.

Обратите внимание, что поток **P** никогда не останавливается, поэтому в этой системе не будет конечного
состояния. Из любого состояния есть, как минимум, переход в котором шаг делает поток **P**.

Самостоятельно проанализируйте полученные результаты:

* Так как каждый поток может быть в одном из 4-х состояний, а переменные *a* и *b* в одном из 2-х состояний,
  то теоретически возможны 4 x 4 x 2 x 2 = 64 состояния. Сколько различных достижимых состояний у вас получилось?
* Возможна ли ситуация, при которой поток **P** находится в состоянии *P3* (critical section) в то время, как поток
  **Q** находится в состоянии *Q4* (завершил выполнение)? Попробуйте объяснить это наблюдение.
* Верно ли, что из любого состояние системы достижимо состояние *Q4*, при котором поток **Q** завершил выполнение?
  Почему так?

# 4.Синхронизация с помощью тонкой блокировки

Задание включает в себя следующие исходные файлы:

* [`4.Bank/Bank.kt`](src/Bank.kt) содержит интерфейс для гипотетического банка.
* [`4.Bank/BankImpl.kt`](src/BankImpl.kt) содержит реализацию операций банка для однопоточного случая.
  Данная реализация небезопасна для использования из нескольких потоков одновременно.

Необходимо доработать реализую `BackImpl` так, чтобы она стала безопасной для использования из множества потоков одновременно. 

* Для реализации необходимо использовать тонкую блокировку. 
  * Синхронизация должна осуществляться для каждого счета по отдельности. 
  * Добавьте поле `lock` типа `java.util.concurrent.locks.ReentrantLock` (класс для примитива блокировки) в класс `BankImpl.Account`
    и используйте его для блокировки операций над соответствующим счетом.
  * В Kotlin можно использовать [`lock.withLock { ... }`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.concurrent/java.util.concurrent.locks.-lock/with-lock.html)
    для работы с одним или двумя счетами, но для блокировки всех счетов потребуется напрямую использовать методы `lock()` и `unlock()`.
* Для обеспечения линеаризуемости операций должна использоваться двухфазная блокировка для всех операций.
* Для избегания ситуации взаимной блокировки (deadlock) необходимо использовать иерархическую блокировку.
* Весь код должен содержаться в файле `4.Bank/BankImpl.kt`
  * В случае использования Java, удалите `src/BankImpl.kt` и скопируйте `java/BankImpl.java` в `src/BankImpl.java` в качестве шаблона кода.
* **В заголовке файла, в строке `@author` впишите вашу фамилию и имя**.

# 5.Ошибочный алгоритм Лампорта

В рамках данного задания вы проанализируете некорректную попытку реализации алгоритма Лампорта для взаимного исключения.

Вася Пупкин увидел второй вариант реализации алгоритма Лампора (см. лекцию), очень порадовался его простоте и решил его соптимизировать. Он избавился от массива `choosing` и получил вот такой код, явно расписав процедуру выбора
максимальной метки в отдельный цикл, используя значение *0* для обозначения
отсутсвия интереса потока к взятию блокировки:

```java
threadlocal int id       // 0..N-1 -- идентификатор потока
shared      int label[N] // заполненно нулями по умолчанию

def lock:
  1: my = 1 // номер билета текущего потока
  2: for k in range(N): if k != id:
  3:     my = max(my, label[k] + 1) // должен быть больше, чем у других
  4: label[id] = my // публикуем свой номер билета для других потоков
  5: for k in range(N): if k != id:
  6:     while true: // пропускаем поток k до тех пока, пока номер его билета меньше
  7:         other = label[k] // читаем номер билета потока k
  8:         if other == 0 or (other, k) > (my, id): break@6 // если номер его билета меньше, перестаем ждать  

def unlock:
  9: label[id] = 0
```

Чтения и записи элементов разделяемого массива `label` происходят атомарно.

Обратите внимание, что Вася ожидал подвох с чтениями элементов массива `label`, поэтому на строке 7 вставил отдельное чтение из массива `label` в локальную переменную `other`, чтобы дальше проанализировать его значение не проводя несколько отдельных операций чтения (иначе разные чтения могут прочитать разные значения).

## Задание

1. Продемонстрируйте испольнение данного алгоритма на двух потоках
(`N == 2`), которое нарушает условие взаимного исключения.

 Описание исполнения должно содержаться в файле [execution](5.Lamport/execution) и содержать набор событий (одно событие = одна строка) в следующем формате:

 ```
 <tid> <line> <action> <location> <value>
 ```

* `<tid>` - id потока, `0` или `1`;
* `<line>` - номер строчки кода, которая исполняется; `3`, `4` или `7`;
* `<action>` - тип события, `rd` (чтение) или `wr` (запись)
* `<location>` - описание разделяемой переменной, к которой происходит обращение, `label[<index>]`;
* `<value>` - значение, которое записано или прочитано; например, `10`.

 Для проверки корректности вашего примера, запустите `./gradlew run` из корня репозитория.

 Если у вас не получается найти решение силой мысли, то проанализуйте в черновике варианты одновременного исполнения двумя потоками операции `lock` методом чередования операций. Обратите внимание, что при анализе вас интересуют только те строки кода, которые обращаются к разделяемым переменным. В данном слуаче это обращения к элементам массива `label` (строки 3, 4, 7).

Подумайте, как можно было бы исправить этот код не заводя отдельного массива `choosing`, но используя концептуально похожую идею.

# 6.Parallel Dijkstra Algorithm

В этом задании вам необходимо реализовать параллельную версию алгоритма Дейкстры с использованием Multi-Queue в качестве приоритетной очереди. Решение, в котором поддерживается счетчик суммарного количества вершин в очереди и в процессе обработки (как рассказано на лекции) считается корректным. Для обновления расстояния до вершины необходимо использовать операцию CAS.

Для тех, кто хочет получить больше пользы от выполнения задания, предлагается поддерживать счетчики количества пустых очередей (чтобы понимать, когда вершин для обработки нет и потенциально необходимо завершиться) и счетчик ждущих вершину для обработки потоков (последний поток, который входит в фазу ожидания, завершает алгоритм). Ожидание должно быть активным (проверка необходимого условия в цикле), никакие `wait`, `park` и прочие примитивы использовать не нужно.

Статьи для домашнего чтения, если хочется разобраться с теорией про Multi-Queue:

1. [The Power of Choice in Priority Scheduling by Dan Alistarh, Justin Kopinsky, Jerry Li, Giorgi Nadiradze](https://arxiv.org/abs/1706.04178)
2. [Efficiency Guarantees for Parallel Incremental Algorithms under Relaxed Schedulers by Dan Alistarh, Nikita Koval, Giorgi Nadiradze](https://arxiv.org/abs/2003.09363)

Проект содержит следующие файлы:

* `Graph.kt` содержит классы `Node` и `Edge`, которые вы будете использовать в алгоритме. Для обновления расстояния до вершины необходимо использовать `distanceMutable.compareAndSet(..)`.
* `Dijkstra.kt` содержит шаблон для параллельной версии алгоритма, его вам и требуется дописать.

## Ограничения

Разрешается изменять только файл `Dijkstra.kt`.

# 7.Множество на основе односвязного списка

Проект включает в себя следующие исходные файлы:

* `Set.java` содержит интерфейс множества.
* `SetImpl.java` содержит реализацию множества на основе односвязного списка для однопоточного случая. Данная реализация небезопасна для использования из нескольких потоков одновременно.

Необходимо доработать реализую `SetImpl` так, чтобы она стала безопасной для использования из множества потоков одновременно.
Используйте неблокирующую синхронизацию для всех операций.
Вместо `AtomicMarkableReference` предлагается в поле `next` хранить либо `Node` (когда флаг `removed == false`), либо специально добавленный `class Removed { final Node next; }` (когда `removed == true`).
Таким образом, чтобы проверить, выставлен ли флаг `removed`, необходимо написать `next instanceof Removed`.
Посмотрите на реализацию `AtomicMarkableReference`, она примерно так и сделана.

# 8.Lock-Free Skip-List

В этом задании вам необходимо реализовать lock-free алгоритм skip-list-а, который основывается на тех же идеях,
что и рассказанный на лекции алгоритм множеста на односвязаном списке.
Однако, skip-list работает за $\mathcal{O}(\log(N))$_ амортизированно, где $N$ - количество элементов.

Хорошее описание алгоритмы вы можете найти в книжке "The Art of Multiprocessor Programming"
от M. Herlihy и N. Shavit. Вероятно, вы найдете еще что-нибудь интересное там!

В файле [`src/SkipListSet.kt`](8.Skip%20List/SkipListSet.kt) находится однопоточная реализация
skip list-а, которую вам необходимо доработать. Операции `add` и `remove` должны
быть lock-free, а операция `contains` -- wait-free.

# 9.Монотонные часы

В рамках данного задания необходимо реализовать алгоритм монотонных часов на регулярных регистрах.

В файле [`9.Monotonic Clock/MonotonicClock.kt`](9.Monotonic%20Clock/MonotonicClock.kt) находится описание интерфейса часов, которые вам предстоит реализовать. Время, которое показывают часы, состоит из трёх целочисленных переменных `d1`, `d2` и `d3`, задающих время от старшего разряда к младшему. Все времена упорядочены лексикографически.

```kotlin
data class Time(val d1: Int, val d2: Int, val d3: Int)
```

Интерфейс часов должен реализовывать операции записи и чтения. Один поток пишет монотонно увеличивающееся время,
а другой поток его читает. Не обязательно, чтобы чтения другого потока были линеаризуемы, но важно, чтобы другой поток видел монотонно возрастающие времена и видел правильное время, если чтения времени не происходит параллельно с его записью.

```kotlin
interface MonotonicClock {
    fun write(time: Time)
    fun read(): Time
}
```

В вашем распоряжении есть класс [`RegularInt`](9.Monotonic%20Clock/RegularInt.kt), который моделирует регулярный
регистр с операциями чтения и записи.

Студент узнал про трюк с чтением в одном порядке и записью в другом и попытался его реализовать.
Вы найдете его решения:

* На языке Kotlin в файле [`9.Monotonic Clock/Solution.kt`](9.Monotonic%20Clock//SolutionTemplateKt.kt)

Однако эти решения не проходят тесты и показывают немонотонное время при чтении.

## Задание

Возьмите за основу одно из предоставленных решений и скопируйте его в файл `9.Monotonic Clock/Solution.(kt|java)`.
Вы должны написать в этом файле реализую монотонных часов, используя фиксированное число переменных типа `RegularInt` для хранения текущего записанного времени. Использование блокировок и других механизмов синхронизации запрещено. Ваше решение должно поддерживать весь диапазон потенциальных времен, то есть должно сохранять переданное в функцию `write` время как минимум в трех регулярных целочисленных переменных (но может использовать и больше).
**В заголовке строке файла, в строке `@author` впишите вашу фамилию и имя**.

Для проверки корректности вашего решения запустите `./gradlew run` из корня репозитория.

Один из вариантов решения описан в работе Лампорта
[Concurrent Reading and Writing of Clocks](http://lamport.azurewebsites.net/pubs/lamport-concurrent-clocks.pdf).

# 10.Универсальная Конструкция

В рамках данного задания необходимо с помощью универсальной lock-free конструкции реализовать счетчик с атомарной операцией инкремента на основе объекта консенсуса.

## Задание

В файле [`10.Universal constructor/AtomicCounter.kt`](10.Universal%20constructor/AtomicCounter.kt) находится описание интерфейса счетчика, который вам предстоит реализовать. Вам надо реализовать всего одну операцию:

```kotlin
fun getAndAdd(x: Int): Int
```

В вашем распоряжении есть класс [`Consensus<T>`](10.Universal%20constructor/Consensus.kt), который реализует консенсус на объекте любого типа `T` предоставляя единственную операцию:

```kotlin
fun decide(value: T): T
```

Ваше решение должно быть в файле `Solution.(kt|java)`. Основной класс должен называться `Solution`.

**В заголовке файла, в строке `@author` впишите вашу фамилию и имя**.
В классе решения вы можете использовать объекты типа `Consensus` для синхронизации потоков, объекты типа `ThreadLocal` для хранения состояния внутри потока, и значения типа `Int`. Все поля класса должны быть неизменяемые (`val` в Kotlin, `final` в Java). Массивы использовать нельзя. Для lock-free универсальной конструкции они не нужны. Также вам наверняка потребуется вспомогательный класс, на который вы можете ссылаться, и на который накладываются такие же ограничения. Вспомогательные классы должны быть внутри вашего класса решения.

# 11.Dynamic Array

В этом задании вам необходимо реализовать lock-free динамически расширяемый массив, используя идеи из лекции про хеш-таблицу. В данном случае диаграмма состояний получается куда проще, а перенос элементов остается таким же. Подумайте над тем, как сделать операции `pushBack` и `get` атомарными -- возможно, идейно поможет очередь Майкла-Скотта.

Реализовывать по-настоящему кооперативный перенос элементов в новый массив необязательно, хотя это и очень важно на практике. Для выполнения данного задания допустима реализация, в которой перенос начинают и заканчивают те потоки, которые натолкнулись на необходимость его делать.

В файле [`11.Dynamic Array/DynamicArray.kt`](11.Dynamic%20array/DynamicArray.kt) находится описание интерфейса массива, который  вам необходимо реализовать. Ваше решение должно быть в файле [`11.Dynamic Array/DynamicArrayImpl.kt`](11.Dynamic%20array/DynamicArrayImpl.kt).

# 13.FAA-Based Queue

В этом задании вам необходимо реализовать алгоритм очереди, построенного на списке сегментов, где в каждом сегменте хранится массив с элементами очереди. Основная синхронизация внутри сегмента выполняется при помощи операции `Fetch-And-Add` (см. `getAndIncrement()` на соответствующих примитивах), в то время как сегменты образуют односвязные список по подобию очереди Майкла-Скотта.
Все подробности -- в соответствующей лекции.

В файле [`13.FAA Queue/FAAQueue.kt`](13.FAA%20Queue/FAAQueue.kt) уже содержится однопоточная версия, вам нужно лишь доработать её до многопоточной. Реализация должна быть lock-free.

Полезные статьи:

* [Fast Concurrent Queues for x86 Processors](https://www.cs.tau.ac.il/~mad/publications/ppopp2013-x86queues.pdf)
* [A Wait-free Queue as Fast as Fetch-and-Add](http://chaoran.me/assets/pdf/wfq-ppopp16.pdf)

# 14.Flat-Combining Priority Queue

Написать быструю многопоточную приоритетную очередь непросто. Однако, мы можем применить технику flat combining и использовать быструю бинарную кучу под капотом.

В этом задании вам необходимо доработать [FCPriorityQueue](14.Flat%20Combining%20priority%20queue/FCPriorityQueue.kt) при помощи техники flat combining. В задании не требуется отдельно оптимизировать операцию `peek`, которая не модифицирует приоритетную очередь. Однако, вы можете написать свою версию приоритетной очереди, в которой вызов операции `peek` будет потокобезопасен, и, таким образом, выполнять её вне комбайнера и без ожидания.

# 15.Synchronous Queue

В этом задании вам необходимо реализовать алгоритм для synchronous queue, который основан на очереди Michael и Scott.
Исходную работу вы можете найти по этой [ссылке](https://www.cs.rochester.edu/u/scott/papers/2009_Scherer_CACM_SSQ.pdf).

В отличие от реализации в Java (см. класс `java.util.concurrent.SynchronousQueue`), мы будем реализовывать этот алгоритм для корутин, использую соответствующий механизм для засыпания и пробуждения.

В файле [`15.Synchronous Queue/SynchronousQueue.kt`](15.Synchronous%20queue/SynchronousQueue.kt) находится описание интерфейса synchronous queue, который  вам предстоит реализовать. Ваше решение должно быть в файле [`15.Synchronous Queue/SynchronousQueueMS.kt`](15.Synchronous%20queue/SynchronousQueueMS.kt).

При реализации алгоритма вам может потребоваться начать всю операцию заново после вызова `suspendCoroutine`, вы можете выразить эту логику следующим образом:

```kotlin
val res = suspendCoroutine<Any> sc@ { cont ->
  ...
  if (shouldRetry()) {
    cont.resume(RETRY)
    return@sc
  }
  ...
}
if (res === RETRY) continue
```

# 16.MCS Lock

Оказывается, что замечательное свойтсво алгоритма MCS блокировки, которое заключется в том, что он ждет на своем узле, можно использовать для реализации честной (First Come, First Served) блокировки, которая усыпляет
ждущий поток через `park` и пробуждает его через `unpark`. Вместо того, чтобы крутиться в бесконечном цикле, ожидая пока взявший блокировку поток её освободит, можно крутиться в цикле вида:

```kotlin
while (node.locked) park()
```

А при освобождении блокировки можно будить другой поток, если в его узле предварительно запомнить ссылку на создавший его поток для последующего вызова `unpark`:

```kotlin
node.locked = false
unpark(node.thread)                                                                                           
```

Рассуждение выше касается только ожидание блокировки, которая в данный момент занята другим потоком. Вспомогательное ожидание в коде `unlock` алгоритма MCS блокировки должно выполняться простым циклом.

Вам предостоит написать и отдадить этот код.

## Задание

В файле [`16.MSC-Lock/Lock.kt`](16.MSC-Lock/Lock.kt) находится описание интерфейса блокировки, который вам предстоит реализовать. Так как алгоритму MCS необходимо
передать указатель на свой узел между методами `lock` и `unlock`, то для вашего удобства соотвествующие методы определены так, что `lock` возвращает указатель на узел, который потом будет передан в `unlock`
тестирующим кодом:

```kotlin
fun lock(): N
fun unlock(node: N)
```

То есть, тестирующий код всегда входит в критическую секцию используюя вот такую функцию `withLock`:

```kotlin
inline fun <N> Lock<N>.withLock(block: () -> Unit) {
    val node = lock()
    block()
    unlock(node)
}
```

Ваше решение должно быть в файле `16.MSC-Lock/Solution.(kt|java)`. Основной класс должен называться `Solution`.

Класс решения должен принимать в конструкторе параметр типа [`Environment`](16.MSC-Lock/Environment.kt) и должен взывать методы `park` и `unpark` на экземпляре этого класса, чтобы тесты могли передать вашего алгоритму
тестовую реализацию этих методов для проверки корректности вашего кода.  

В классе решения вы должны использовать объекты типа `AtomicRefernce` для общих пременных между потоками. Для хранения флажка `locked` используйте `AtomicReference<Boolean>`. В языке Kotlin вы можете менять значение атомарных переменных через свойство `value`, например:

```kotlin
val locked = AtomicReference<Boolean>(false) // объявление переменной в классе
locked.value = true // выставить значение в коде 
```

Все поля классов должны быть неизменяемые (`val` в Kotlin, `final` в Java). Массивы использовать нельзя. Также вам потребуется вспомогательный класс для узла, на который вы так же можете ссылаться и на который накладываются такие же ограничения. В шаблоне уже есть пример такого класса. Он также запоминает указатель на поток. Вспомогательные классы должны быть внутри вашего класса решения.

# 17.Lock-Free Bank

Задание включает в себя следующие исходные файлы:

* [`17.Lock-free Bank/Bank.kt`](17.Lock-free%20Bank/Bank.kt) содержит интерфейс для гипотетического банка.
* [`17.Lock-free Bank/BankImpl.kt`](17.Lock-free%20Bank/BankImpl.kt) содержит код-заготовку реализации операций банка без блокировок.

В реализации используются основные идеи из работы "A Practical Multi-Word Compare-and-Swap Operation" by T. L. Harris, c упрощенной (ускоренной) операцией DCSS за счет отсутвия проблемы ABA. Код содержит *todo* коментарии в тех местах, которые необходимо доделать. В этих местах содержится такой код-заглушка, что он работает корректно при использовании из одного потока, но небезопасен для использования из не скольких потоков одновременно.

## Задание

Необходимо доработать реализую `BankImpl` так, чтобы она стала безопасной для использования из множества потоков одновременно.

  1. Написать многопоточную реализацию метода `withdraw`;
  2. Написать реализацию метода `acquire` согласно написанной в нем документации;
  3. Написать реализацию метода `TransferOp.invokeOperation`.
  
Весь код должен содержаться в файле `BankImpl.kt`.

# 19.STM Bank

Задание включает в себя следующие исходные файлы:

* [`19.STM Bank/Bank.kt`](19.STM%20Bank/Bank.kt) содержит интерфейс для гипотетического банка.
* [`19.STM Bank/BankImpl.kt`](19.STM%20Bank/BankImpl.kt) содержит простую реализации операций банка используюя STM.
* [`19.STM Bank/STM.kt`](19.STM%20Bank/STM.kt) содержит незаконченную реализацю obstruction-free STM.

## Задание

Необходимо закончить реализацию STM, написав реализацию метода `TxVar.openIn` вместо написанного там кода-заглушки, который должен открывать пременную в указанной транзакции и применять к ней функцию `update`. Алгоритм такого STM без блокировок описан в учебнике "The Art of Multiprocessor Programming" by Maurice Herlihy and Nir Shavit и был рассказан на лекции.

В качестве алгоритма разрешения конфликтов между транзакциями необходомо отменять незаконченную транзакцию,
которая в данный момент работает над транзакционной переменной, что обеспечивает работу данного алгоритма
без блокировок, а точнее obstruction-free образом.  
  
Весь код должен содержаться в файле `STM.kt`.
